"""
Executor - Plan Execution and Monitoring

The Executor executes plans generated by the Planner and monitors outcomes.
It iterates through plan steps, interfaces with Talos for physical execution,
and provides feedback on success/failure.

Tasks (from Workstream B4):
- Define execution interface (receive plans)
- Implement plan step iteration
- Add success/failure callback mechanism
- Stub out Talos integration (simulated execution)

Reference: Section 3.3, Workstream B4
"""

from collections.abc import Callable
from dataclasses import dataclass
from enum import Enum
from typing import Any


class ExecutionStatus(Enum):
    """Status of plan execution"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class ExecutionResult:
    """Result of executing a single action"""
    action_index: int
    success: bool
    error_message: str | None = None
    execution_time: float = 0.0
    state_changes: dict[str, Any] | None = None


class Executor:
    """
    Plan Executor

    Executes plans generated by the Planner and monitors outcomes.
    The Executor steps through actions, coordinates with Talos for
    physical execution (simulated in Phase 1), and reports results.

    Execution flow:
    1. Receive plan from Planner
    2. Iterate through actions in sequence
    3. For each action:
       a. Check preconditions
       b. Execute via Talos (simulated)
       c. Monitor outcome
       d. Update HCG with state changes
    4. Report success/failure via callbacks

    Attributes:
        current_plan: Plan being executed
        execution_status: Current execution status
        current_action_index: Index of currently executing action
        success_callbacks: Callbacks for successful execution
        failure_callbacks: Callbacks for execution failures
    """

    def __init__(self):
        """Initialize the Executor with no active plan"""
        self.current_plan: Any | None = None  # Will be sophia.planner.Plan
        self.execution_status: ExecutionStatus = ExecutionStatus.NOT_STARTED
        self.current_action_index: int = 0
        self.execution_results: list[ExecutionResult] = []
        self.success_callbacks: list[Callable] = []
        self.failure_callbacks: list[Callable] = []

    def execute_plan(self, plan: Any) -> bool:
        """
        Execute a complete plan.

        Iterates through all actions in the plan, executing each in sequence.
        Monitors for failures and invokes appropriate callbacks.

        Args:
            plan: Plan object from Planner

        Returns:
            True if all actions executed successfully, False otherwise

        Note:
            Phase 1: Simulated execution with stubbed Talos integration
            Phase 2+: Real Talos integration with error handling
        """
        self.current_plan = plan
        self.execution_status = ExecutionStatus.RUNNING
        self.current_action_index = 0
        self.execution_results = []

        try:
            for i, action in enumerate(plan.actions):
                self.current_action_index = i
                result = self._execute_action(action, i)
                self.execution_results.append(result)

                if not result.success:
                    self.execution_status = ExecutionStatus.FAILED
                    self._invoke_failure_callbacks(result)
                    return False

            self.execution_status = ExecutionStatus.COMPLETED
            self._invoke_success_callbacks()
            return True

        except Exception as e:
            self.execution_status = ExecutionStatus.FAILED
            result = ExecutionResult(
                action_index=self.current_action_index,
                success=False,
                error_message=str(e)
            )
            self._invoke_failure_callbacks(result)
            return False

    def _execute_action(self, action: Any, index: int) -> ExecutionResult:
        """
        Execute a single action.

        Args:
            action: Action object to execute
            index: Index of the action in the plan

        Returns:
            ExecutionResult with outcome information

        Note:
            This will interface with Talos for physical execution.
            Phase 1: Simulated execution (always succeeds)
        """
        # TODO: Implement Talos integration
        # This will:
        # 1. Check action preconditions
        # 2. Send command to Talos
        # 3. Monitor execution
        # 4. Update HCG with state changes
        # 5. Return execution result

        # Phase 1 stub: Simulated successful execution
        return ExecutionResult(
            action_index=index,
            success=True,
            execution_time=1.0,
            state_changes={}
        )

    def pause_execution(self) -> None:
        """
        Pause the current execution.

        Note:
            This is a Phase 2+ feature for interactive control
        """
        if self.execution_status == ExecutionStatus.RUNNING:
            self.execution_status = ExecutionStatus.PAUSED

    def resume_execution(self) -> bool:
        """
        Resume a paused execution.

        Returns:
            True if execution resumed successfully

        Note:
            This is a Phase 2+ feature for interactive control
        """
        if self.execution_status == ExecutionStatus.PAUSED:
            self.execution_status = ExecutionStatus.RUNNING
            # TODO: Resume from current_action_index
            return True
        return False

    def abort_execution(self) -> None:
        """
        Abort the current execution.

        Stops execution immediately and transitions to FAILED state.
        """
        self.execution_status = ExecutionStatus.FAILED
        result = ExecutionResult(
            action_index=self.current_action_index,
            success=False,
            error_message="Execution aborted by user"
        )
        self._invoke_failure_callbacks(result)

    def register_success_callback(self, callback: Callable) -> None:
        """
        Register a callback for successful plan execution.

        Args:
            callback: Function to call on successful execution
        """
        self.success_callbacks.append(callback)

    def register_failure_callback(self, callback: Callable) -> None:
        """
        Register a callback for execution failures.

        Args:
            callback: Function to call on execution failure (receives ExecutionResult)
        """
        self.failure_callbacks.append(callback)

    def _invoke_success_callbacks(self) -> None:
        """Invoke all registered success callbacks"""
        for callback in self.success_callbacks:
            callback()

    def _invoke_failure_callbacks(self, result: ExecutionResult) -> None:
        """
        Invoke all registered failure callbacks.

        Args:
            result: ExecutionResult containing failure information
        """
        for callback in self.failure_callbacks:
            callback(result)

    def get_execution_status(self) -> ExecutionStatus:
        """
        Get the current execution status.

        Returns:
            Current ExecutionStatus enum value
        """
        return self.execution_status

    def get_execution_results(self) -> list[ExecutionResult]:
        """
        Get results of all executed actions.

        Returns:
            List of ExecutionResult objects
        """
        return self.execution_results.copy()
